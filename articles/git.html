<article id="git" class="wiki-entry">
  <h1 class="column-header">GIT</h1>
  <section class="sub-section">
    <div id="toc-container">
      <h1 class="column-header toc-header">CONTENT</h1>
      <ul class="toc">
        <li><a href="#primer">PRIMER</a></li>
        <li><a href="#usage">USAGE</a></li>
      </ul>
    </div>
    <p>Version control software serve the purpose of systematically organizing different versions of a project through history. The benefit is making work history parsable, which is turn means that progress can be applied methodically and rolled back when thigs go tits up. There are multiple different tools for this purpose, the most ubiquitous one being <strong>Git</strong>.</p>

    <figure class="blockquote">
      <blockquote cite="https://git-scm.com/docs/git">
        <p>Git - The stupid content tracker</p>
      </blockquote>
      <figcaption>- git(1), <cite><a href="https://git-scm.com/docs/git"> linux manpage</a></cite></figcaption>
    </figure>

    <p>Linus Torvalds, the son of a bitch, wipped up his own operating system kernel when he felt the ones available didn't fit the bill. In order to make work easier, he also designed his own version control system. <a href="https://git-scm.com/">Git</a>, so named partly as a joke, works by storing a complete repository of all changes done in a given directory. This data is always stored in full on the machine where the repository is located. In other words, git operates perfectly offline, and allows a synced workflow by following a predetermined method.</p>

    <p>The learning curve for git is pretty step though. It actually requires you to master the tool to a fair degree to make any use of it. Especially for the person coming directly from a cloud syncing tool, who might confuse git with a backup, git will appear a bit unintuitive at first. Things will quickly get even more complicated when you are trying to co-operate with other people who aren't proficient users. One might be forgiven for thinking that git doesn't make things easier for the developer. People may argue that point, but it may be more effective to accept git simply as a <b>tool for systematically lock in changes</b> and then provide a method to roll these changes back and forth without loosing information. If you need that, then huzzah. If you don't, you'll have no need for git.</p>

    <p>When getting started with git, you should primarily be making use of the official website. Some very useful links are listed in the table below for easy access. Before you get busy digging through all the documentation though, you might want to read on below for a little bit of an crash course intro to make navigation easier.</p>

    <table>
      <caption>Recommended points for further reading</caption>
      <colgroup span="2"></colgroup>
      <tr>
        <td>Git official website</td>
        <td><a href="https://git-scm.com/">https://git-scm.com/</a></td>
      </tr>
      <tr>
        <td>Git References, the same resource available through linux manpages</td>
        <td><a href="https://git-scm.com/docs">https://git-scm.com/docs</a></td>
      </tr>
      <tr>
        <td>Pro Git book, written by Scott Chacon and Ben Straub and published by Apress</td>
        <td><a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a></td>
      </tr>
    </table>

  </section>

  <h2 id="primer">PRIMER</h2>
  <section class="sub-section">
    <p>One excellent place to start, along with this section, is the git introduction chapter of <a href="https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F">Pro Git 2ed (Chacon & Straub)</a>. This is all to set git in context. There will be a fair deal of taxonomy that takes a while to learn before one can make sense of what's happening. The concepts mentioned in this section should set you well on your way to start grasping how git fits together.</p>

    <p>First, we must talk about the <strong>repository</strong>. Git is the program and the interface we use to achieve version control. But it operates on top of the existing filesystem. Git doesn't set up a complicated environment but is rather designed to operate on top of whatever else you're already doing. Any directory can become a designated repository. The root of the repo is where git stores all it's configuration metadata, and all sub folders will be recognized and handled by git. Anything above the repo root however will mean nothing, which is why you can move repositories around very freely. When you move through the project history, you will actually rewrite the files in the physical memory.</p>

    <p>A repository is <strong>cloned</strong> into a file system by git. The act of cloning is essentially making a local copy. Git offers plenty of functionality to automate the process and clone over a network connection, which is how multiple users can collaborate on a single repository. You are not, however, giving other people access to your computer when you collaborate with them. Instead, you create a local copy, which is then <strong>pushed</strong>, i.e writes all new changes, to a <strong>remote repository</strong>, often just refered to as <em>"the remote"</em>.</p>

    <p>For a remote to be accessible over the internet, it needs to be hosted which opens up a whole other can of worms. One practical way to achieve remote hosting for the beginner is <a href="https://github.com/">github.com</a>. Be advised that github operates a large framework on top of git that might be a little confuisng at first, but for the purpose of easily creating a shared resource, it's perfect!</p>

    <p>Once there is a repository, which you have cloned onto your computer, you'll start doing work. Git creates a tree structure with any number of <strong>branches</strong> that can separate the work however the developer pleases. Git designates one of the branches to be the primary one, historically called <strong>master</strong> or <strong>main</strong>. More than anything, this is to allow one of the branches to operate as the outward facing one, while changes are being done compatmentalized in another branch.</p>

    <p>Switching between branches is called a <strong>checkout</strong>. Any move through project history is similarly refered to as "<em>checking out</em>". Other than branching, you can also do a slightly more extensive operation called <strong>fork</strong>. In short, a fork creates a completely new direction with a new master branch. It entirely diverts the project history in a separate direction, for when you want to take the work in a completely new direction.</p>

    <p>There are three stages in which git can recognize a file and understanding how they flow together is key to effectively utilizing the tool. These are all important to understand fairly well. They're not especially complicated, but you'll want to take a look in the <a href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository">git book</a> as soon as possible. Just to get started, they will be quickly presented here:</p>

    <ul>
      <li>Git <b>tracks</b>  changes. Once any change has been done to a file, git will consider it as <strong>modified</strong>.</li>
      <li>Some of these changes are good enough to keep around. These will be <strong>staged</strong>, which sets them apart from the rest. Some or all of the changes in a repository can be staged line by line.</li>
      <li>Once modifications have been staged to the authors pleasure, they are <strong>commited</strong> to perpetuity, creating a permanent point of history and entering them into the annals of git forever. Write <span class="inline code">git log</span> in the terminal to see them all.</li>
    </ul>

    <p>The <em>"commits"</em> are the points which can be traversed freely, rolling the version hirstory of a directory back and forth.</p>

    <h3 id="beginners-advise">Beginners Advice</h3>
    <p>As a last piece of useful information, this section will simply list a couple of practical advise that may help give some actionable tips when getting started.</p>
    <ol>
      <li>Only commit changes that make a consistent difference. Git isn't intended to use as a backup system. There is no point to arbitrarily commit content that isn't fullfilling any level of working order. It is better to commit multiple, smaller and concrete changes, perhaps when some functionality has been implemented or a certain bug got fixed. It is common for beginner to mistakenly use git as some kind of backup, which is perfectly possible, but not very meaningful.</li>
      <li>Don't work all over the place at once. Just pick a goal to work towards and do that particular thing. When commits stretch over several files and several components, they will get very messy very fast and untangling them can become really difficult.</li>
      <li>Create a branch when you start working on any level of larger change and only merge that back to the master branch when the work is done and the changes work acceptably well.</li>
      <li>Keep your log clean. Clear commit messages goes a long way to make the project progress easier to follow and navigate in the case where you might need to go back.</li>
      <li>Don't use git with cloud sync software. It will give you all kinds of wacky back and forths as both git and the cloud software tries to sort out what happened every time you checkout a new branch.</li>
      <li>Make good use of the gitignore file. It allows you to instruct git to ignore certain files that don't need shared with others, e.g executables, locals tests etc. You'll find an intro in section <a href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository">2.2 <em>Ignoring Files</em></a> of the book.</li>
    </ol>
  </section>

  <h2 id="usage">USAGE</h2>
  <section class="sub-section">
    <p>This section aims to gather a few common but useful instructions on how to practically use git, where digging deep in the documentation often is could be avoided.</p>

    <h3 id="stashing">STASHING</h3>
    <p>Used to store away partially finished work that is not yet ready for a commit. It uses a simple push and pop structure where we simply cram any changes we want into a box. This allows us to start working on something completely different from the latest established commit. This can be particularly useful when doing work in a branch, but you quickly need to hop over to another to fix something else. For details, use <span class="inline code">man git stash</span> or check out the <a href="https://git-scm.com/docs/git-stash">official docs page</a></p>
    <table>
      <caption>Common git stash examples</caption>
      <colgroup span="2"></colgroup>
      <tr>
        <td><span class="inline code">git stash</span></td>
        <td>Stash all untracked changes. </td>
      </tr>
      <tr>
        <td><span class="inline code">git stash pop</span></td>
        <td>Pop the most recently stashed entry</td>
      </tr>
      <tr>
        <td><span class="inline code">git stash push -m <em>&ltmessage&gt</em> <em>&ltfiles&gt</em></span></td>
        <td>Push the specified files along with the associated message onto the stack</td>
      </tr>
    </table>
    <p>Use the <span class="inline code">-u</span> option to include untracked changes. The <span class="inline code">-p</span> option can also be added to create a patched stash entry.</p>
    <div class="box attention">
      <p>By using stash before pulling new changes into a repository will simplify potential conflicts.</p>
    </div>

    <h3 id="rebasing">REBASING</h3>
    <p>Instead of merging branches, rebasing can be used to simply place all changes in some branch on top of another. The benefits here is a more streamlined and traversable log, along with less headache with merge conflicts.</p>
    <div class="box snippet code">git rebase <em>&ltsome branch&gt</em></div>
    <p>The above will simply relocate all changes in "some branch" on top of the current branch. Use git stash if any uncommited changes have a chance to create conflicts that require resolving.</p>
  </section>
</article>
