<article id="version-control" class="wiki-entry">
  <h1 class="column-header">VERSION CONTROL</h1>
  <section class="sub-section">
    <div id="toc-container">
      <h1 class="column-header toc-header">Table Of Contents</h1>
      <ul class="toc">
        <li><a href="#git">Git</a></li>
      </ul>
    </div>
    <p>Version control software serve the purpose of systematically organizing different versions of a project through history. The benefit is making work history parsable, which is turn means that progress can be applied methodically and rolled back when thigs go tits up. There are multiple different tools for this purpose, the most ubiquitous one being <strong>Git</strong>.</p>
  </section>

  <h2 id="#git">Git</h2>
  <section class="sub-section">
    <figure class="blockquote">
      <blockquote cite="https://git-scm.com/docs/git">
        <p>Git - The stupid content tracker</p>
      </blockquote>
      <figcaption>- git(1), <cite><a href="https://git-scm.com/docs/git"> linux manpage</a></cite></figcaption>
    </figure>

    <p>Linus Torvalds, the son of a bitch, wipped up his own operating system kernel when he felt the ones available didn't fit the bill. In order to make work easier, he also designed his own version control system. <a href="https://git-scm.com/">Git</a>, so named partly as a joke, works by storing a complete repository of all changes done in a given directory. This data is always stored in full on the machine where the repository is located. In other words, git operates perfectly offline, and allows a synced workflow by following a predetermined method.</p>

    <p>The learning curve for git is pretty step though. It actually requires you to master the tool to a fair degree to make any use of it. Especially for the person coming directly from a cloud syncing tool, who might confuse git with a backup, git will appear a bit unintuitive at first. Things will quickly get even more complicated when you are trying to co-operate with other people who aren't proficient users. One might be forgiven for thinking that git doesn't make things easier for the developer. People may argue that point, but it may be more effective to accept git simply as a <b>tool for systematically lock in changes</b> and then provide a method to roll these changes back and forth without loosing information. If you need that, then huzzah. If you don't, you'll have no need for git.</p>

    <p>When getting started with git, you should primarily be making use of the official website. Some very useful links are listed in the table below for easy access. Before you get busy digging through all the documentation though, you might want to read on below for a little bit of an crash course intro to make navigation easier.</p>

    <table>
      <caption>Recommended points for further reading</caption>
      <colgroup span="2"></colgroup>
      <tr>
        <td>Git official website</td>
        <td><a href="https://git-scm.com/">https://git-scm.com/</a></td>
      </tr>
      <tr>
        <td>Git References, the same resource available through linux manpages</td>
        <td><a href="https://git-scm.com/docs">https://git-scm.com/docs</a></td>
      </tr>
      <tr>
        <td>Pro Git book, written by Scott Chacon and Ben Straub and published by Apress</td>
        <td><a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a></td>
      </tr>
    </table>

    <h3 id="git-glossary-primer">Git Glossary Primer</h3>
    <p>One excellent place to start, along with this section, is the git introduction chapter of <a href="https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F">Pro Git 2ed (Chacon & Straub)</a>. This is all to set git in context. There will be a fair deal of taxonomy that takes a while to learn before one can make sense of what's happening. The concepts mentioned in this section should set you well on your way to start grasping how git fits together.</p>

    <p>First, we must talk about the <strong>repository</strong>. Git is the program and the interface we use to achieve version control. But it operates inside the existing filesystem. Git doesn't set up a complicated environment but is rather designed to operate on top of whatever else you're already doing. Any directory can become a designated repository. The root of the repo is where git stores all it's configuration metadata, and all sub folders will be recognized and handled by git. Anything above the repo root however will mean nothing, which is why you can move repositories around very freely. When you move through the project history, you will actually rewrite the files in the physical memory.</p>

    <p>A repository is <strong>cloned</strong> into a file system by git. The act of cloning is essentially making a local copy. Git offers plenty of functionality to automate the process and clone over a network connection, which is how multiple users can collaborate on a single repository. You are not, however, giving other people access to your computer when you collaborate with them. Instead, you create a local copy, which is then <strong>pushed</strong>, i.e writes all new changes, to a <strong>remote repository</strong>, often just refered to as <em>"the remote"</em>.</p>

    <p>For a remote to be accessible over the internet, it needs to be hosted which opens up a whole other can of worms. One practical way to achieve remote hosting for the beginner is <a href="https://github.com/">github.com</a>. Be advised that github operates a large framework on top of git that might be a little confuisng at first, but for the purpose of easily creating a shared resource, it's perfect!</p>

    <p>Once there is a repository, which you have cloned onto your computer, you'll start doing work. Git creates a tree structure with any number of <strong>branches</strong> that can separate the work however the developer pleases. Git designates one of the branches to be the primary one, historically called <strong>master</strong> or <strong>main</strong>. More than anything, this is to allow one of the branches to operate as the outward facing one, while changes are being done compatmentalized in another branch.</p>

    <p>Switching between branches is called a <strong>checkout</strong>. Any move through project history is similarly refered to as "<em>checking out</em>". Other than branching, you can also do a slightly more extensive operation called <strong>fork</strong>. In short, a fork creates a completely new direction with a new master branch. It entirely diverts the project history in a separate direction, for when you want to take the work in a completely new direction.</p>

    <p>There are three stages in which git can recognize a file and understanding how they flow together is key to effectively utilizing the tool. As mentioned, git only <b>tracks</b> changes. The files themselves are simply the result of applying these changes from the ground up. If a change has been applied to a file, for instance a line of text has been added, git will see the file as <strong>Modified</strong>.
    <br>
    This only means git knows that something is different since last time changes where locked in place. In order to solidify a change, we must <strong>Stage</strong> the changes. Staged is a state that multiple files can be take to prepare them all to be locked in. Any number of changes can be staged at the same time, even partial changes to a single file.
    <br>
    Finally, when we've applied the changes we want and they have all been staged, then we can <strong>Commit</strong> them, immortalizing them in the annals of git forever. The version history in git is simply a list of commited changes that represent version states of a directory. This list can be traversed freely to transform the directory into what the files looked like at that time, either to diverge again from that point, or perhaps roll back some unexpected side-effects.</p>


    <h3 id="beginners-advise">Beginners Advice</h3>
    <p>As a last piece of useful information, this section will simply list a couple of practical advise that may help give some actionable tips when getting started.</p>
    <ol>
      <li>Only commit changes that make a consistent difference. Git isn't intended to use as a backup system. There is no point to arbitrarily commit content that isn't fullfilling any level of working order. It is better to commit multiple, smaller and concrete changes, perhaps when some functionality has been implemented or a certain bug got fixed.</li>
      <li>Don't work all over the place at once. Just pick a goal to work towards and do that particular thing. When commits stretch over several files and several components, they will get very messy very fast and untangling them can become really difficult.</li>
      <li>Create a branch when you start working on any level of larger change and only merge that back to the master branch when the work is done and the changes work acceptably well.</li>
      <li>Keep your log clean. Clear commit messages goes a long way to make the project progress easier to follow and navigate in the case where you might need to go back.</li>
      <li>Don't use git with cloud sync software. It will give you all kinds of wacky back and forths as both git and the cloud software tries to sort out what happened every time you checkout a new branch.</li>
    </ol>
  </section>
</article>
